# 텍스쳐
우리는 객체에 더 많은 디테일을 추가하기 위해 각 정점에 색상을 지정하여 흥미로운 이미지를 만들 수 있다는 것을 알게 되었습니다. 하지만 상당한 사실감을 얻으려면 많은 정점이 필요하고 그만큼 많은 색상을 지정해야 합니다. 이는 각 모델에 더 많은 정점이 필요하고 각 정점에 색상 속성이 있어야 하므로 상당한 추가 오버헤드를 발생시킵니다.

일반적으로 아티스트와 프로그래머들이 선호하는 방식은 **텍스처**{:.g}를 사용하는 것입니다. 텍스처는 객체에 디테일을 더하기 위해 사용되는 2D 이미지입니다(1D 및 3D 텍스처도 존재합니다). 예를 들어, 멋진 벽돌 이미지가 그려진 종이를 3D 집 위에 깔끔하게 접어 붙여 집 외벽이 돌로 된 것처럼 보이게 하는 것을 텍스처라고 생각해 보세요. 하나의 이미지에 많은 디테일을 담을 수 있기 때문에, 추가적인 정점을 지정하지 않고도 객체가 매우 정교해 보이는 효과를 줄 수 있습니다.

!!! tip ""
    이미지 외에도 텍스처는 셰이더로 전송할 다양한 종류의 데이터를 저장하는 데 사용할 수 있지만, 이는 다른 주제에서 다루도록 하겠습니다.

아래 이미지는 이전 장에서 다룬 삼각형에 [벽돌 벽의 텍스처](../static/wall.jpg)를 적용한 것입니다.

![](../static/textures.png)

삼각형에 텍스처를 매핑하려면 삼각형의 각 정점에 텍스처의 어느 부분에 해당하는지 알려줘야 합니다. 따라서 각 정점에는 텍스처 이미지의 어느 부분을 샘플링할지 지정하는 **텍스처 좌표(texture coordinate)**{:.g}가 연결되어야 합니다. 그런 다음 프래그먼트 보간이 나머지 프래그먼트에 대해 작업을 수행합니다.

텍스처 좌표는 x축과 y축에서 0부터 1까지의 범위를 갖습니다(2D 텍스처 이미지를 사용한다는 점을 기억하세요). 텍스처 좌표를 사용하여 텍스처 색상을 추출하는 것을 **샘플링(sampling)**{:.g}이라고 합니다. 텍스처 좌표는 텍스처 이미지의 왼쪽 아래 모서리를 (0,0)에서 시작하여 오른쪽 위 모서리를 (1,1)에서 시작합니다. 다음 이미지는 텍스처 좌표를 삼각형에 매핑하는 방법을 보여줍니다.

![](../static/tex_coords.png)

삼각형에 대해 3개의 텍스처 좌표점을 지정합니다. 삼각형의 왼쪽 아래 변이 텍스처의 왼쪽 아래 변과 일치하도록 (0,0)을 왼쪽 아래 꼭짓점으로 사용합니다. 오른쪽 아래 변도 마찬가지로 (1,0)을 텍스처 좌표로 사용합니다. 삼각형의 윗면은 텍스처 이미지의 중앙 상단에 해당해야 하므로 (0.5,1.0)을 텍스처 좌표로 사용합니다. 정점 셰이더에는 3개의 텍스처 좌표만 전달하면 되며, 정점 셰이더는 이 좌표들을 프래그먼트 셰이더로 전달하여 각 프래그먼트에 대해 모든 텍스처 좌표를 깔끔하게 보간합니다.

그러면 결과적인 텍스처 좌표는 다음과 같습니다.

```c++
float texCoords[] = {
    0.0f, 0.0f,  // lower-left corner  
    1.0f, 0.0f,  // lower-right corner
    0.5f, 1.0f   // top-center corner
};
```

텍스처 샘플링은 해석이 자유롭고 다양한 방식으로 구현될 수 있습니다. 따라서 우리는 OpenGL에게 텍스처를 어떻게 샘플링해야 하는지 알려주는 것이 우리의 역할입니다.

## 텍스쳐 래핑

텍스처 좌표는 일반적으로 (0,0)에서 (1,1) 사이의 범위를 갖지만, 이 범위를 벗어난 좌표를 지정하면 어떻게 될까요? OpenGL의 기본 동작은 텍스처 이미지를 반복하는 것입니다(기본적으로 부동 소수점 텍스처 좌표의 정수 부분을 무시합니다). 하지만 OpenGL은 더 많은 옵션을 제공합니다.

 - `GL_REPEAT`: 텍스처의 기본 동작입니다. 텍스처 이미지를 반복합니다.
 - `GL_MIRRORED_REPEAT`: `GL_REPEAT`와 동일하지만, 반복할 때마다 이미지를 좌우 반전시킵니다.
 - `GL_CLAMP_TO_EDGE`: 좌표를 0에서 1 사이로 제한합니다. 결과적으로 더 높은 좌표는 가장자리에 고정되어 가장자리 패턴이 늘어나는 현상이 발생합니다.
 - `GL_CLAMP_TO_BORDER`: 이제 범위를 벗어난 좌표에는 사용자가 지정한 테두리 색상이 적용됩니다.

각 옵션은 기본 범위를 벗어난 텍스처 좌표를 사용할 때 서로 다른 시각적 결과를 보여줍니다. 샘플 텍스처 이미지에서 이러한 결과가 어떻게 나타나는지 살펴보겠습니다. (원본 이미지: Hólger Rezende)

![](../static/texture_wrapping.png)

앞서 언급한 각 옵션은 `glTexParameter*` 함수를 사용하여 좌표축(s, t (3D 텍스처를 사용하는 경우 r 포함), x, y, z에 해당)별로 설정할 수 있습니다.

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
```

첫 번째 인수는 텍스처 대상을 지정합니다. 2D 텍스처를 사용하므로 텍스처 대상은 `GL_TEXTURE_2D`입니다. 두 번째 인수는 설정할 옵션과 적용할 텍스처 축을 지정해야 합니다. 여기서는 S축과 T축 모두에 대해 설정을 구성하려고 합니다. 마지막 인수는 원하는 텍스처 래핑 모드를 전달해야 합니다. 이 경우 OpenGL은 현재 활성화된 텍스처에 `GL_MIRRORED_REPEAT` 옵션을 적용합니다.

`GL_CLAMP_TO_BORDER` 옵션을 선택하는 경우 테두리 색상도 지정해야 합니다. 이는 `glTexParameter` 함수의 fv 버전에 해당하는 함수를 사용하고, 옵션으로 `GL_TEXTURE_BORDER_COLOR`를 지정하며, 테두리 색상 값을 담은 float 배열을 전달함으로써 수행됩니다.

```c++
float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };
glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 
```

## 텍스쳐 필터링

텍스처 좌표는 해상도에 의존하지 않고 임의의 부동 소수점 값이 될 수 있으므로, OpenGL은 해당 텍스처 좌표를 어떤 텍스처 픽셀(**텍셀(texel)**{:.g}이라고도 함)에 매핑해야 하는지 파악해야 합니다. 이는 특히 크기가 매우 큰 객체와 저해상도 텍스처를 사용하는 경우에 중요해집니다. 짐작하셨겠지만, OpenGL에는 이러한 **텍스처 필터링**{:.g}을 위한 옵션도 있습니다. 여러 옵션이 있지만, 여기서는 가장 중요한 옵션인 `GL_NEAREST`와 `GL_LINEAR`에 대해 살펴보겠습니다.

`GL_NEAREST`(**최근접 이웃**{:.g} 또는 **점**{:.g} 필터링이라고도 함)는 OpenGL의 기본 텍스처 필터링 방식입니다. `GL_NEAREST`로 설정하면 OpenGL은 텍스처 좌표에 가장 가까운 중심을 가진 텍셀을 선택합니다. 아래 그림에서 십자 표시는 정확한 텍스처 좌표를 나타내는 4개의 픽셀을 보여줍니다. 왼쪽 상단의 텍셀이 텍스처 좌표에 가장 가까운 중심을 가지고 있으므로 샘플링된 색상으로 선택됩니다.

![](../static/filter_nearest.png)

GL_LINEAR(또는 **선형 필터링((bi)linear filtering)**{:.g})는 텍스처 좌표의 인접한 텍셀에서 보간된 값을 가져와 텍셀 사이의 색상을 근사합니다. 텍스처 좌표에서 텍셀 중심까지의 거리가 작을수록 해당 텍셀의 색상이 샘플링된 색상에 더 많이 기여합니다. 아래 예시에서 인접한 픽셀의 색상이 혼합된 값이 반환되는 것을 볼 수 있습니다.

![](../static/filter_linear.png)

그렇다면 이러한 텍스처 필터링 방법의 시각적 효과는 어떨까요? 해상도가 낮은 텍스처를 큰 객체에 적용할 때(텍스처가 확대되어 개별 텍셀이 눈에 띄게 됨) 이러한 방법들이 어떻게 작동하는지 살펴보겠습니다.

![](../static/texture_filtering.png)

`GL_NEAREST`는 텍스처를 구성하는 픽셀이 명확하게 보이는 블록 패턴을 생성하는 반면, `GL_LINEAR`는 개별 픽셀이 덜 보이는 더 부드러운 패턴을 생성합니다. `GL_LINEAR`는 더 사실적인 출력을 제공하지만, 일부 개발자는 8비트 느낌을 선호하여 `GL_NEAREST` 옵션을 선택하기도 합니다.

텍스처 필터링은 **확대(magnifying)**{:.g} 및 **축소(minifying)**{:.g} 작업(크기 조정 시)에 대해 따로 설정할 수 있으므로, 예를 들어 텍스처 크기를 줄일 때는 최근접 이웃 필터링을 사용하고 확대할 때는 선형 필터링을 사용할 수 있습니다. 따라서 `glTexParameter*`를 통해 두 가지 옵션 모두에 대한 필터링 방법을 지정해야 합니다. 코드는 래핑 방법을 설정하는 코드와 유사합니다.

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

### 밉맵

수천 개의 객체가 있는 넓은 방을 상상해 보세요. 각 객체에는 텍스처가 적용되어 있습니다. 멀리 있는 객체들도 가까이 있는 객체들과 동일한 고해상도 텍스처를 가지고 있을 것입니다. 객체가 멀리 있고, 생성되는 프래그먼트가 적을 경우, OpenGL은 고해상도 텍스처에서 해당 프래그먼트에 맞는 색상 값을 가져오는 데 어려움을 겪습니다. 텍스처의 상당 부분을 차지하는 프래그먼트에 대한 색상 값을 선택해야 하기 때문입니다. 이로 인해 작은 객체에서 눈에 띄는 아티팩트가 발생할 뿐만 아니라, 작은 객체에 고해상도 텍스처를 사용하는 것은 메모리 대역폭 낭비로 이어집니다.

이 문제를 해결하기 위해 OpenGL은 **밉맵(mipmaps)**{:.g}이라는 개념을 사용합니다. 밉맵은 기본적으로 텍스처 이미지들의 모음으로, 각 텍스처는 이전 텍스처보다 크기가 절반씩 작습니다. 밉맵의 원리는 간단합니다. 뷰어에서 특정 거리 임계값을 초과하면 OpenGL은 객체와의 거리에 가장 적합한 다른 밉맵 텍스처를 사용합니다. 객체가 멀리 떨어져 있기 때문에 해상도가 낮아도 사용자는 알아차리지 못합니다. 따라서 OpenGL은 적절한 텍셀을 샘플링할 수 있으며, 밉맵의 해당 부분을 샘플링할 때 캐시 메모리 사용량도 줄어듭니다. 밉맵이 적용된 텍스처가 어떻게 생겼는지 자세히 살펴보겠습니다.

![](../static/mipmaps.png)

각 텍스처 이미지에 대해 밉맵이 적용된 텍스처 모음을 수동으로 생성하는 것은 번거롭지만, 다행히 OpenGL은 텍스처를 생성한 후 `glGenerateMipmap`을 한 번만 호출하면 모든 작업을 자동으로 처리해 줍니다.

OpenGL은 렌더링 중 밉맵 레벨을 전환할 때 두 밉맵 레이어 사이에 날카로운 경계가 나타나는 등의 아티팩트가 나타날 수 있습니다. 일반적인 텍스처 필터링과 마찬가지로, `NEAREST` 및 `LINEAR` 필터링을 사용하여 밉맵 레벨 간 전환을 위한 필터링을 적용할 수 있습니다. 밉맵 레벨 간 필터링 방법을 지정하려면 기존 필터링 방법을 다음 네 가지 옵션 중 하나로 대체하면 됩니다.

 - `GL_NEAREST_MIPMAP_NEAREST`: 픽셀 크기와 일치하는 가장 가까운 밉맵을 가져오고 텍스처 샘플링에 최근접 이웃 보간법을 사용합니다.
 - `GL_LINEAR_MIPMAP_NEAREST`: 가장 가까운 밉맵 레벨을 가져와 선형 보간법을 사용하여 해당 레벨을 샘플링합니다.
 - `GL_NEAREST_MIPMAP_LINEAR`: 픽셀 크기와 가장 유사한 두 밉맵 사이를 선형적으로 보간하고, 최근접 이웃 보간법을 통해 보간된 레벨을 샘플링합니다.
 - `GL_LINEAR_MIPMAP_LINEAR`: 가장 가까운 두 밉맵 사이를 선형 보간하고 선형 보간을 통해 보간된 레벨을 샘플링합니다.

텍스처 필터링과 마찬가지로 `glTexParameteri`를 사용하여 앞서 언급한 4가지 방법 중 하나로 필터링 방법을 설정할 수 있습니다.

```c++
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
```

흔히 저지르는 실수 중 하나는 밉맵 필터링 옵션 중 하나를 확대 필터로 설정하는 것입니다. 밉맵은 주로 텍스처 크기를 줄일 때 사용되므로, 텍스처 확대에는 밉맵이 적용되지 않습니다. 따라서 밉맵 필터링 옵션을 지정하면 OpenGL `GL_INVALID_ENUM` 오류 코드가 발생합니다.

## 텍스처 불러오기 및 생성

텍스처를 실제로 사용하려면 먼저 텍스처 이미지를 애플리케이션에 불러와야 합니다. 텍스처 이미지는 수십 가지 파일 형식으로 저장될 수 있으며, 각 형식마다 고유한 구조와 데이터 순서를 가지고 있습니다. 그렇다면 이러한 이미지를 애플리케이션에서 어떻게 불러올 수 있을까요? 한 가지 방법은 사용하려는 파일 형식(예: .PNG)을 선택하고 해당 형식을 큰 바이트 배열로 변환하는 자체 이미지 로더를 작성하는 것입니다. 자체 이미지 로더를 작성하는 것이 아주 어렵지는 않지만, 여전히 번거롭고, 더 많은 파일 형식을 지원해야 한다면 어떻게 될까요? 지원하려는 각 형식마다 이미지 로더를 작성해야 합니다.

또 다른 해결책이자 아마도 좋은 방법은 여러 인기 있는 이미지 형식을 지원하고 모든 어려운 작업을 대신 처리해주는 이미지 로딩 라이브러리를 사용하는 것입니다. stb_image.h와 같은 라이브러리가 그 예입니다.

### stb_image.h

stb_image.h는 [Sean Barrett](https://github.com/nothings)이 개발한 매우 인기 있는 단일 헤더 이미지 로딩 라이브러리로, 대부분의 인기 있는 파일 형식을 로드할 수 있으며 프로젝트에 쉽게 통합할 수 있습니다. stb_image.h는 [여기](https://github.com/nothings/stb/blob/master/stb_image.h)에서 다운로드할 수 있습니다. 단일 헤더 파일을 다운로드하고 프로젝트에 stb_image.h로 추가한 다음, 다음 코드가 포함된 C++ 파일을 추가로 생성하면 됩니다.

```c++
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
```

`STB_IMAGE_IMPLEMENTATION`을 정의하면 전처리기가 헤더 파일을 수정하여 관련 정의 소스 코드만 포함하도록 만듭니다. 이렇게 하면 헤더 파일이 사실상 .cpp 파일이 됩니다. 이제 프로그램의 적절한 위치에 stb_image.h를 포함하고 컴파일하면 됩니다.

다음 텍스처 섹션에서는 [나무 상자 이미지](../static/container.jpg)를 사용하겠습니다. stb_image.h를 사용하여 이미지를 로드하려면 `stbi_load` 함수를 사용합니다.

```c++
int width, height, nrChannels;
unsigned char *data = stbi_load("container.jpg", &width, &height, &nrChannels, 0);
```

이 함수는 먼저 이미지 파일의 위치를 ​​입력으로 받습니다. 그런 다음 두 번째, 세 번째, 네 번째 인수로 세 개의 정수를 입력받아야 하는데, stb_image.h 파일은 이 값들을 결과 이미지의 너비, 높이, 그리고 색상 채널 수로 채웁니다. 이미지의 너비와 높이는 나중에 텍스처를 생성하는 데 필요합니다.


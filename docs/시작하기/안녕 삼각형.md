# 안녕 삼각형

OpenGL에서는 모든 것이 3차원 공간에 있지만, 화면이나 창은 픽셀로 이루어진 2차원 배열입니다. 따라서 OpenGL의 주요 기능은 모든 3차원 좌표를 화면에 맞는 2차원 픽셀로 변환하는 것입니다. 3차원 좌표를 2차원 픽셀로 변환하는 과정은 OpenGL의 **그래픽 파이프라인(graphics pipeline)**{:.g}에서 처리됩니다. 그래픽 파이프라인은 크게 두 부분으로 나눌 수 있는데, 첫 번째 부분은 3차원 좌표를 화면에 그리기 위한 2차원 좌표로 변환하고, 두 번째 부분은 2차원 좌표를 실제 색상이 있는 픽셀로 변환합니다. 이 장에서는 그래픽 파이프라인에 대해 간략하게 살펴보고, 이를 활용하여 멋진 픽셀을 만드는 방법을 알아보겠습니다.

그래픽 파이프라인은 3D 좌표 세트를 입력으로 받아 화면상의 색상이 있는 2D 픽셀로 변환합니다. 그래픽 파이프라인은 여러 단계로 나눌 수 있으며, 각 단계는 이전 단계의 출력을 입력으로 필요로 합니다. 이러한 모든 단계는 고도로 전문화되어(각각 특정 기능만 수행) 병렬로 실행될 수 있습니다. 이러한 병렬 처리 특성 덕분에 오늘날의 그래픽 카드는 그래픽 파이프라인 내에서 데이터를 빠르게 처리하기 위해 수천 개의 소형 처리 코어를 갖추고 있습니다. 처리 코어는 파이프라인의 각 단계에 대해 GPU에서 작은 프로그램을 실행합니다. 이러한 작은 프로그램을 **셰이더**{:.g}라고 합니다.

일부 셰이더는 개발자가 구성할 수 있으므로 기존의 기본 셰이더를 대체할 자체 셰이더를 작성할 수 있습니다. 이를 통해 파이프라인의 특정 부분을 훨씬 더 세밀하게 제어할 수 있으며, GPU에서 실행되므로 귀중한 CPU 시간도 절약할 수 있습니다. 셰이더는 **OpenGL 셰이딩 언어**{:.g}(**OpenGL Shading Language**{:.g}, **GLSL**{:.g})로 작성되며, 다음 장에서 이에 대해 자세히 살펴보겠습니다.

아래는 그래픽 파이프라인의 모든 단계를 추상적으로 나타낸 것입니다. 파란색 부분은 우리가 직접 셰이더를 삽입할 수 있는 영역을 나타냅니다.

![](../static/pipeline.png)

보시다시피, 그래픽 파이프라인은 정점 데이터를 완전한 픽셀 렌더링으로 변환하는 과정의 각 부분을 처리하는 수많은 섹션으로 구성되어 있습니다. 파이프라인의 작동 방식을 쉽게 이해할 수 있도록 각 섹션을 간략하게 설명하겠습니다.

그래픽 파이프라인의 입력으로는 'Vertex Data'라는 배열에 삼각형을 형성해야 하는 세 개의 3D 좌표 목록을 전달합니다. 이 **정점(vertex)**{:.g} 데이터는 정점들의 모음입니다. 각 정점은 3D 좌표에 대한 데이터 모음입니다. 정점의 데이터는 **정점 속성(vertex attributes)**{:.g}을 사용하여 표현되며, 이 속성에는 원하는 모든 데이터를 담을 수 있지만, 간단하게 설명하기 위해 각 정점은 3D 위치와 색상 값으로만 ​​구성된다고 가정하겠습니다.

!!! tip ""
    OpenGL이 좌표와 색상 값의 모음을 어떻게 처리해야 할지 알기 위해서는, 어떤 종류의 렌더링 유형을 만들 것인지에 대한 힌트를 제공해야 합니다. 데이터를 점들의 모음으로 렌더링할지, 삼각형들의 모음으로 렌더링할지, 아니면 하나의 긴 선으로 렌더링할지 등을 지정해야 합니다. 이러한 힌트를 **프리미티브(primitives)**{:.g}라고 하며, 그리기 명령을 호출할 때 OpenGL에 전달됩니다. 이러한 힌트에는 GL_POINTS, GL_TRIANGLES, GL_LINE_STRIP 등이 있습니다.

파이프라인의 첫 번째 부분은 단일 정점을 입력으로 받는 **정점 셰이더**{:.g}입니다. 정점 셰이더의 주요 목적은 3D 좌표를 다른 3D 좌표로 변환하는 것이며(자세한 내용은 나중에 설명), 정점 속성에 대한 기본적인 처리를 수행할 수 있도록 해줍니다.

정점 셰이더 단계의 출력은 선택적으로 **지오메트리 셰이더**{:.g}로 전달됩니다. 지오메트리 셰이더는 기본 도형을 구성하는 정점들의 모음을 입력으로 받으며, 새로운 정점을 생성하여 새로운 (또는 다른) 기본 도형을 만들어 다른 형태를 생성할 수 있습니다. 이 예제에서는 주어진 도형에서 두 번째 삼각형을 생성합니다.

**기본 도형 조립(primitive assembly)**{:.g} 단계는 정점 셰이더(또는 `GL_POINTS`가 선택된 경우 정점)에서 하나 이상의 기본 도형을 구성하는 모든 정점을 입력으로 받아 주어진 기본 도형 모양(이 경우 두 개의 삼각형)의 모든 점을 조립합니다.

기본 도형 조립 단계의 출력은 **래스터화 단계(rasterization stage)**{:.g}로 전달되어 최종 화면의 해당 픽셀에 매핑됩니다. 이렇게 생성된 프래그먼트는 프래그먼트 셰이더에서 사용됩니다. 프래그먼트 셰이더가 실행되기 전에 **클리핑**{:.g}이 수행됩니다. 클리핑은 사용자의 시야 범위를 벗어난 모든 프래그먼트를 제거하여 성능을 향상시킵니다.

!!! tip ""
    OpenGL에서 프래그먼트는 OpenGL이 단일 픽셀을 렌더링하는 데 필요한 모든 데이터입니다.

**프래그먼트 셰이더(fragment shader)**{:.g}의 주요 목적은 픽셀의 최종 색상을 계산하는 것이며, 일반적으로 모든 고급 OpenGL 효과가 구현되는 단계입니다. 프래그먼트 셰이더는 보통 3D 장면에 대한 데이터(예: 조명, 그림자, 조명의 색상 등)를 포함하고 있으며, 이를 사용하여 최종 픽셀 색상을 계산합니다.

모든 해당 색상 값이 결정되면 최종 객체는 **알파 테스트**{:.g} 및 **블렌딩 단계**{:.g}라고 하는 마지막 단계를 거칩니다. 이 단계에서는 프래그먼트의 해당 깊이(및 스텐실) 값(나중에 자세히 설명)을 확인하고, 결과 프래그먼트가 다른 객체 앞에 있는지 뒤에 있는지 판단하여 그에 따라 폐기해야 하는지 결정합니다. 또한 **알파**{:.g} 값(알파 값은 객체의 불투명도를 정의함)을 확인하고 그에 따라 객체를 **블렌딩**{:.g}합니다. 따라서 프래그먼트 셰이더에서 픽셀 출력 색상이 계산되더라도 여러 삼각형을 렌더링할 때 최종 픽셀 색상은 완전히 다를 수 있습니다.

보시다시피 그래픽 파이프라인은 상당히 복잡하며 여러 가지 설정 가능한 부분을 포함하고 있습니다. 하지만 거의 모든 경우에 우리는 정점 셰이더와 프래그먼트 셰이더만 사용하면 됩니다. 지오메트리 셰이더는 선택 사항이며 일반적으로 기본 셰이더를 사용합니다. 또한 여기서는 묘사하지 않았지만 테셀레이션 단계와 변환 피드백 루프가 있으며, 이는 나중에 자세히 다루겠습니다.

최신 OpenGL에서는 정점 셰이더와 프래그먼트 셰이더를 직접 정의해야 합니다(GPU에 기본 정점/프래그먼트 셰이더가 제공되지 않습니다). 따라서 최신 OpenGL을 배우기 시작하는 것은 상당히 어려울 수 있습니다. 첫 번째 삼각형을 렌더링하기 전에 많은 지식이 필요하기 때문입니다. 하지만 이 장을 마치고 마침내 삼각형을 렌더링하게 되면 그래픽 프로그래밍에 대해 훨씬 더 많이 알게 될 것입니다.

## 정점 입력

무언가를 그리기 시작하려면 먼저 OpenGL에 정점 데이터를 입력해야 합니다. OpenGL은 3D 그래픽 라이브러리이므로 OpenGL에서 지정하는 모든 좌표는 3D 공간(x, y, z 좌표)에 있습니다. OpenGL은 모든 3D 좌표를 화면의 2D 픽셀로 단순히 변환하지 않습니다. OpenGL은 3축(x, y, z) 모두에서 좌표가 -1.0에서 1.0 사이의 특정 범위에 있을 때만 3D 좌표를 처리합니다. 이른바 **정규화된 장치 좌표(normalized device coordinates)**{:.g} 범위 내에 있는 모든 좌표는 화면에 표시되고, 이 범위를 벗어난 좌표는 표시되지 않습니다.

하나의 삼각형을 렌더링하기 위해 총 세 개의 정점을 지정해야 하며, 각 정점은 3D 위치를 갖습니다. 이 정점들은 OpenGL의 가시 영역인 정규화된 장치 좌표계로 아래와 같은 float 배열에 정의됩니다.

```c++
float vertices[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};  
```

OpenGL은 3D 공간에서 작동하기 때문에 각 꼭짓점의 z축 좌표가 0.0인 2D 삼각형을 렌더링합니다. 이렇게 하면 삼각형의 깊이가 그대로 유지되어 2D처럼 보이게 됩니다.

!!! tip "Normalized Device Coordinates (NDC)"
    정점 셰이더에서 정점 좌표가 처리되면, x, y, z 값이 -1.0에서 1.0 사이의 작은 범위인 **정규화된 장치 좌표(normalized device coordinates)**{:.g}로 변환됩니다. 이 범위를 벗어나는 좌표는 버려지거나 잘려나가 화면에 표시되지 않습니다. 아래 그림에서 정규화된 장치 좌표(z축 제외)로 표현된 삼각형을 확인할 수 있습니다.

    ![](../static/ndc.png)

    일반적인 화면 좌표계와 달리 양의 y축은 위쪽 방향을 가리키고 (0,0) 좌표는 그래프의 왼쪽 상단이 아닌 중앙에 위치합니다. 최종적으로 모든 (변환된) 좌표가 이 좌표 공간 안에 있어야 하며, 그렇지 않으면 표시되지 않습니다.

    그러면 NDC 좌표는 `glViewport` 함수로 제공한 데이터를 사용하여 **뷰포트 변환(viewport transform)**{:.g}을 통해 **화면 공간 좌표(screen-space coordinates)**{:.g}로 변환됩니다. 이렇게 변환된 화면 공간 좌표는 다시 프래그먼트 셰이더의 입력으로 사용될 프래그먼트 좌표로 변환됩니다.

정점 데이터가 정의되었으므로, 이를 그래픽 파이프라인의 첫 번째 프로세스인 정점 셰이더의 입력으로 보내려고 합니다. 이를 위해 GPU에 정점 데이터를 저장할 메모리를 생성하고, OpenGL이 해당 메모리를 해석하는 방식을 구성하며, 데이터를 그래픽 카드로 전송하는 방법을 지정합니다. 그러면 정점 셰이더는 메모리에 저장된 데이터를 사용하여 지정된 만큼의 정점을 처리합니다.

우리는 GPU 메모리에 많은 수의 정점을 저장할 수 있는 **정점 버퍼 객체**{:.g}(**vertex buffer objects**{:.g}, **VBO**{:.g})를 통해 메모리를 관리합니다. 이러한 버퍼 객체를 사용하는 장점은 대량의 데이터를 한 번에 그래픽 카드로 전송하고, 메모리 여유가 있다면 데이터를 저장할 수 있다는 것입니다. 즉, 데이터를 정점별로 하나씩 전송할 필요가 없습니다. CPU에서 그래픽 카드로 데이터를 전송하는 것은 상대적으로 느리기 때문에 가능한 한 번에 한 많은 데이터를 전송하는 것이 좋습니다. 데이터가 그래픽 카드 메모리에 저장되면 정점 셰이더는 거의 즉시 정점에 접근할 수 있으므로 매우 빠른 처리 속도를 구현할 수 있습니다.

정점 버퍼 객체는 OpenGL 챕터에서 설명했듯이 OpenGL 객체의 첫 번째 예입니다. OpenGL의 다른 객체와 마찬가지로 이 버퍼에도 고유한 ID가 있으므로 `glGenBuffers` 함수를 사용하여 버퍼 ID와 함께 정점 버퍼 객체를 생성할 수 있습니다.

```c++
unsigned int VBO;
glGenBuffers(1, &VBO);
```

OpenGL에는 여러 종류의 버퍼 객체가 있으며, 정점 버퍼 객체의 버퍼 유형은 `GL_ARRAY_BUFFER`입니다. OpenGL에서는 서로 다른 버퍼 유형을 가진 버퍼들이라면 여러 개를 동시에 바인딩할 수 있습니다. `glBindBuffer` 함수를 사용하여 새로 생성된 버퍼를 `GL_ARRAY_BUFFER` 대상에 바인딩할 수 있습니다.

```c++
glBindBuffer(GL_ARRAY_BUFFER, VBO);
```

그 시점부터 `GL_ARRAY_BUFFER` 유형에 대한 모든 버퍼 호출은 현재 바인딩된 버퍼(VBO)를 구성하는 데 사용됩니다. 이제 `glBufferData` 함수를 호출하여 이전에 정의한 정점 데이터를 버퍼로 복사할 수 있습니다.

```c++
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
```

`glBufferData` 함수는 현재 바인딩된 버퍼에 사용자 정의 데이터를 복사하는 데 사용되는 함수입니다. 첫 번째 인수는 데이터를 복사할 버퍼의 유형입니다. 현재 GL_ARRAY_BUFFER 대상에 정점 버퍼 객체가 바인딩되어 있습니다. 두 번째 인수는 버퍼에 전달할 데이터의 크기(바이트)를 지정합니다. 정점 데이터의 sizeof 값을 사용하면 충분합니다. 세 번째 매개변수는 실제로 전송할 데이터입니다.

네 번째 매개변수는 그래픽 카드가 주어진 데이터를 처리하는 방식을 지정합니다. 아래에 있는 세 가지 형식 중 하나를 사용할 수 있습니다.

 - `GL_STREAM_DRAW`: 데이터는 한 번만 설정되며 GPU에서 최대 몇 번만 사용됩니다.
 - `GL_STATIC_DRAW`: 데이터는 한 번만 설정되고 여러 번 사용됩니다.
 - `GL_DYNAMIC_DRAW`: 데이터가 자주 변경되고 여러 번 사용됩니다.

삼각형의 위치 데이터는 변경되지 않고, 자주 사용되며, 모든 렌더링 호출에서 동일하게 유지되므로 사용 유형은 `GL_STATIC_DRAW`가 가장 적합합니다. 예를 들어, 자주 변경될 가능성이 있는 데이터가 담긴 버퍼가 있는 경우, `GL_DYNAMIC_DRAW` 사용 유형을 사용하면 그래픽 카드가 더 빠른 쓰기가 가능한 메모리 영역에 데이터를 배치하게 됩니다.

지금까지 우리는 `VBO`라는 정점 버퍼 객체를 통해 그래픽 카드의 메모리에 정점 데이터를 저장해 왔습니다. 다음으로 이 데이터를 실제로 처리하는 정점 셰이더와 프래그먼트 셰이더를 만들어 보겠습니다.

## 정점 셰이더

정점 셰이더는 우리와 같은 개발자가 직접 프로그래밍할 수 있는 셰이더 중 하나입니다. 최신 OpenGL에서는 렌더링을 하려면 최소한 정점 셰이더와 프래그먼트 셰이더를 설정해야 하므로, 여기서는 셰이더를 간략하게 소개하고 첫 번째 삼각형을 그리는 두 가지 간단한 셰이더를 구성해 보겠습니다.

먼저 GLSL(OpenGL Shading Language) 셰이더 언어로 정점 셰이더를 작성하고, 이 셰이더를 컴파일하여 애플리케이션에서 사용할 수 있도록 해야 합니다. 아래는 GLSL로 작성된 매우 기본적인 정점 셰이더의 소스 코드입니다.

```glsl
#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
```

보시다시피 GLSL은 C 언어와 유사합니다. 각 셰이더는 버전 선언으로 시작합니다. OpenGL 3.3 이상 버전부터 GLSL의 버전 번호는 OpenGL 버전과 일치합니다(예: GLSL 버전 420은 OpenGL 버전 4.2에 해당). 또한 "core"라는 단어를 통해 코어 프로파일링 기능을 사용하고 있음을 명시적으로 언급합니다.

다음으로, `in` 키워드를 사용하여 정점 셰이더에서 입력받는 모든 정점 속성을 선언합니다. 지금은 좌표 데이터만 필요하므로 하나의 정점 속성만 있으면 됩니다. GLSL에는 뒤에 붙는 숫자에 따라 크기가 달라지는 벡터 타입이 있는데, 해당 숫자는 1개에서 4개의 부동 소수점을 저장할 수 있음을 의미합니다. 각 정점은 3D 좌표를 가지므로 `aPos`라는 이름으로 `vec3` 타입의 입력 변수를 정의합니다. 또한 레이아웃(location = 0)을 통해 입력 변수의 위치를 ​​명시적으로 설정하는데, 나중에 이 위치가 왜 필요한지 알게 될 것입니다.

!!! tip "벡터(Vector)"
    그래픽 프로그래밍에서 벡터는 공간상의 위치/방향을 깔끔하게 표현할 수 있고 유용한 수학적 속성을 지니고 있기 때문에 수학적 개념으로서 매우 자주 사용됩니다. GLSL에서 벡터는 최대 크기가 4이며, 각각 `vec.x`, `vec.y`, `vec.z`, `vec.w`를 통해 접근할 수 있습니다. 여기서 `vec.w`는 공간상의 좌표를 나타냅니다. 참고로 `vec.w`는 공간상의 위치(3D 공간에서 다루기 때문에 4D 공간은 고려하지 않음)가 아니라 **원근 분할(perspective division)**{:.g}이라는 용도로 사용됩니다. 벡터에 대해서는 이후 장에서 더 자세히 다룰 예정입니다.

정점 셰이더의 출력을 설정하려면 미리 정의된 gl_Position 변수에 위치 데이터를 할당해야 합니다. 이 변수는 내부적으로 vec4 타입입니다. **main**{:.r} 함수 끝에서 gl_Position에 설정한 값이 정점 셰이더의 출력으로 사용됩니다. 입력값이 3 크기의 벡터이므로 4 크기의 벡터로 형변환해야 합니다. 이를 위해 vec3 값을 vec4 생성자에 넣고 w 구성요소를 1.0f로 설정합니다(이유는 나중에 설명하겠습니다).

현재의 정점 셰이더는 입력 데이터에 대한 어떠한 처리도 하지 않고 단순히 셰이더의 출력으로 전달하기 때문에 아마도 우리가 상상할 수 있는 가장 단순한 정점 셰이더일 것입니다. 실제 응용 프로그램에서는 입력 데이터가 일반적으로 정규화된 장치 좌표계에 있지 않으므로 먼저 입력 데이터를 OpenGL의 가시 영역 내에 속하는 좌표계로 변환해야 합니다.

## 셰이더 컴파일하기

우리는 정점 셰이더의 소스 코드를 가져와서 일단은 코드 파일 맨 위에 있는 상수 C 문자열에 저장합니다.

```c++
const char *vertexShaderSource = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
    "}\0";
```

OpenGL이 셰이더를 사용하려면 소스 코드에서 실행중에 동적으로 컴파일해야 합니다. 먼저 ID로 참조되는 셰이더 객체를 생성해야 합니다. 따라서 정점 셰이더 객체의 아이디 변수를 부호 없는 정수로 선언하고 `glCreateShader`를 사용하여 셰이더 객체를 생성합니다.

```c++
unsigned int vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
```

`glCreateShader` 함수에 생성할 셰이더 유형을 인수로 전달합니다. 여기서는 정점 셰이더를 생성하므로 `GL_VERTEX_SHADER`를 전달합니다.

다음으로 셰이더 소스 코드를 셰이더 객체에 연결하고 셰이더를 컴파일합니다.

```c++
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);
```

`glShaderSource` 함수는 첫 번째 인수로 컴파일된 셰이더와 연결할 셰이더 객체를 받습니다. 두 번째 인수는 소스 코드로 전달할 문자열의 개수를 지정하는데, 이는 보통 1로 둡니다. 셰세 번째 매개변수는 실제 정점 셰이더의 소스 코드이며, 네 번째 매개변수는 소스코드의 길이지만 보통 OpenGL이 알아서 처리하므로 `NULL`로 둘수 있습니다.

!!! tip ""
    `glCompileShader` 호출 후 컴파일이 성공했는지, 실패했다면 어떤 오류가 발생했는지 확인하여 수정하는 것이 좋습니다. 컴파일중 발생하는 오류를 확인하는 방법은 이렇습니다.

    ```c++
    int  success;
    char infoLog[512];
    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
    ```

    먼저 컴파일 성공을 나타내는 정수와 오류 메시지(있을 경우)를 저장할 컨테이너를 정의합니다. 그런 다음 `glGetShaderiv` 함수를 사용하여 컴파일이 성공했는지 확인합니다. 컴파일에 실패한 경우 `glGetShaderInfoLog` 함수를 사용하여 오류 메시지를 가져와 출력합니다.

    ```c++
    if(!success)
    {
        glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
        std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
    }
    ```

정점 셰이더 컴파일 중에 오류가 발견되지 않으면 컴파일이 완료됩니다.

## 프래그먼트 셰이더

프래그먼트 셰이더는 삼각형을 렌더링하기 위해 만들 두 번째이자 마지막 셰이더입니다. 프래그먼트 셰이더는 픽셀의 색상 출력을 계산하는 역할을 합니다. 간단하게 설명하기 위해 프래그먼트 셰이더는 항상 주황색 계열의 색상을 출력하도록 하겠습니다.

```glsl
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 
```

프래그먼트 셰이더는 최종 색상 출력을 정의하는 크기 4의 벡터 출력 변수 하나만 필요로 합니다. 이 색상 값은 우리가 직접 계산해야 합니다. `out` 키워드를 사용하여 출력 값을 선언할 수 있으며, 여기서는 간단하게 `FragColor`라고 명명했습니다. 다음으로, 알파 값 1.0(완전히 불투명함)을 가진, 주황색을 표현하는 벡터를 색상 출력에 할당합니다.

프래그먼트 셰이더를 컴파일하는 과정은 버텍스 셰이더와 유사하지만, 이번에는 셰이더 유형으로 `GL_FRAGMENT_SHADER` 상수를 사용합니다.

```c++
unsigned int fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
glCompileShader(fragmentShader);
```

이제 두 셰이더 모두 컴파일되었으며, 남은 작업은 두 셰이더 객체를 하나의 렌더링에 사용할 수 있는 **셰이더 프로그램(Shader program)**{:.g}으로 링크하는 것뿐입니다. 여기서도 컴파일 오류가 없는지 꼭 확인하세요!

### 셰이더 프로그램

셰이더 프로그램 객체는 여러 셰이더를 결합한 최종 링크 버전입니다. 최근 컴파일된 셰이더를 사용하려면 셰이더 프로그램 객체에 **링크**{:.g}한 다음, 객체를 렌더링할 때 이 셰이더 프로그램을 활성화해야 합니다. 활성화된 셰이더 프로그램의 셰이더는 렌더링 호출 시 사용됩니다.

셰이더를 프로그램에 연결할 때 각 셰이더의 출력을 다음 셰이더의 입력에 연결합니다. 출력과 입력이 일치하지 않으면 이 단계에서 연결 오류가 발생합니다.

프로그램 객체를 생성하는 것은 간단합니다.

```c++
unsigned int shaderProgram;
shaderProgram = glCreateProgram();
```

`glCreateProgram` 함수는 프로그램을 생성하고 새로 생성된 프로그램 객체의 ID 참조를 반환합니다. 이제 이전에 컴파일한 셰이더를 프로그램 객체에 연결한 다음 `glLinkProgram` 함수를 사용하여 링크해야 합니다.

```c++
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
```

코드는 꽤 직관적입니다. 셰이더를 프로그램에 연결하고 `glLinkProgram`을 통해 연결합니다.

!!! tip ""
    셰이더 컴파일과 마찬가지로 셰이더 프로그램 링크 실패 여부를 확인하고 해당 로그를 가져올 수 있습니다. 하지만 `glGetShaderiv` 및 `glGetShaderInfoLog` 대신 다음 함수를 사용합니다.

    ```c++
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if(!success) {
        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
        ...
    }
    ```

결과적으로 프로그램 객체가 생성되는데, 이 객체를 `glUseProgram` 함수에 인수로 전달하여 활성화할 수 있습니다.

```c++
glUseProgram(shaderProgram);
```

`glUseProgram` 이후의 모든 셰이더 및 렌더링 호출은 이제 이 프로그램 객체(셰이더)를 사용하게 됩니다.

아, 그리고 셰이더 객체를 프로그램 객체에 연결했으면 이제 삭제하는 걸 잊지 마세요. 더 이상 필요 없으니까요.

```c++
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);  
```

지금 우리는 입력 정점 데이터를 GPU로 보내고, 정점 셰이더와 프래그먼트 셰이더 내에서 정점 데이터를 어떻게 처리해야 하는지 GPU에 지시했습니다. 거의 다 왔지만 아직 완벽하지는 않습니다. OpenGL은 아직 메모리에 있는 정점 데이터를 어떻게 해석하고 정점 셰이더의 속성에 어떻게 연결해야 하는지 알지 못합니다. 우리가 친절하게 OpenGL에게 그 방법을 알려줄 것입니다.

# 정점 속성 연결

정점 셰이더를 사용하면 정점 속성 형태로 모든 입력의 모양을 원하는대로 지정할 수 있습니다. 이는 뛰어난 유연성을 제공하지만, 입력 데이터의 어떤 부분이 정점 셰이더의 어떤 정점 속성에 해당하는지 수동으로 지정해야 한다는 것을 의미합니다. 즉, 렌더링 전에 OpenGL이 정점 데이터를 어떻게 해석해야 하는지 지정해야 합니다.

정점 버퍼 데이터는 다음과 같은 형식으로 되어 있습니다.

![](../static/vertex_attribute_pointer.png)

 - 위치 데이터는 32비트(4바이트) 부동소수점 값으로 저장됩니다.
 - 각 위치는 이러한 값 중 3개로 구성됩니다.
 - 세 개의 값으로 이루어진 각 세트 사이에는 공백(또는 다른 값)이 없습니다. 값들이 배열에 **빽빽하게 채워져(tightly packed)**{:.g} 있습니다.
 - 데이터의 첫 번째 값은 버퍼의 시작 부분에 있습니다.

이러한 정보를 바탕으로 `glVertexAttribPointer` 함수를 사용하여 OpenGL에게 정점 데이터(정점 속성별)를 어떻게 해석해야 하는지 알려줄 수 있습니다.

```c++
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);  
```

`glVertexAttribPointer` 함수는 매개변수가 꽤 많으므로 하나씩 자세히 살펴보겠습니다.

 - 첫 번째 매개변수는 구성할 정점 속성을 지정합니다. 정점 셰이더에서 레이아웃(location = 0)을 사용하여 위치 정점 속성의 위치를 ​​지정했음을 기억하세요. 이는 정점 속성의 위치를 ​​0으로 설정하며, 이 정점 속성에 데이터를 전달해야 하므로 0을 전달합니다.
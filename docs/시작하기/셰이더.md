# 셰이더

[안녕 삼각형](안녕 삼각형.md) 챕터에서 언급했듯이, 셰이더는 GPU에서 실행되는 작은 프로그램입니다. 이러한 프로그램은 그래픽 파이프라인의 각 특정 단계에서 실행됩니다. 간단히 말해, 셰이더는 입력을 출력으로 변환하는 프로그램에 지나지 않습니다. 또한 셰이더는 서로 통신할 수 없도록 매우 독립적으로 작동하는 프로그램입니다. 셰이더 간의 통신은 오직 입력과 출력을 통해서만 이루어집니다.

이전 장에서는 셰이더의 기본적인 개념과 올바른 사용법을 간략하게 살펴보았습니다. 이제 셰이더, 특히 OpenGL 셰이딩 언어에 대해 보다 일반적인 방식으로 설명하겠습니다.

## GLSL

셰이더는 C와 유사한 언어인 GLSL로 작성됩니다. GLSL은 그래픽 작업에 최적화되어 있으며, 벡터 및 행렬 조작에 특화된 유용한 기능들을 포함하고 있습니다.

셰이더는 항상 버전 선언으로 시작하고, 그 뒤에 입력 및 출력 변수 목록, 유니폼(uniforms) 변수, 그리고 메인 함수가 이어집니다. 각 셰이더의 진입점은 메인 함수이며, 여기서 입력 변수를 처리하고 결과를 출력 변수에 출력합니다. 유니폼 변수가 무엇인지 모르더라도 걱정하지 마세요. 곧 설명드리겠습니다.

셰이더는 일반적으로 다음과 같은 구조를 가지고 있습니다.

```glsl
#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;
  
uniform type uniform_name;
  
void main()
{
  // 입력값을 처리하고 여러가지 그래픽 작업 수행
  ...
  // 처리된 결과를 출력 변수에 출력
  out_variable_name = weird_stuff_we_processed;
}
```

정점 셰이더에 대해 구체적으로 이야기할 때, 각 입력 변수는 **정점 속성(vertex attribute)**{:.g}이라고도 합니다. 선언할 수 있는 정점 속성의 최대 개수는 하드웨어에 의해 제한됩니다. OpenGL은 항상 최소 16개의 4성분 정점 속성을 사용할 수 있도록 보장하지만, 일부 하드웨어에서는 더 많은 속성을 허용할 수 있으며, 이는 `GL_MAX_VERTEX_ATTRIBS`를 쿼리하여 확인할 수 있습니다.

```c++
int nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
std::cout << "Maximum nr of vertex attributes supported: " << nrAttributes << std::endl;
```

이 함수는 대개 최소값인 16을 반환하는데, 이는 대부분의 목적에 충분할 것입니다.

### 타입

GLSL은 다른 프로그래밍 언어와 마찬가지로 변수의 종류를 지정하는 데이터 타입을 가지고 있습니다. GLSL에는 C 언어에서 흔히 볼 수 있는 int, float, double, uint, bool과 같은 기본 타입이 대부분 포함되어 있습니다. 또한, 벡터와 행렬이라는 두 가지 컨테이너 타입을 많이 사용하게 될 것입니다. 행렬에 대해서는 이후 장에서 자세히 다루겠습니다.

#### 벡터

GLSL에서 벡터는 방금 언급한 기본 유형들을 담을 수 있는 2, 3 또는 4개의 구성 요소로 이루어진 컨테이너입니다. 벡터는 다음과 같은 형태를 취할 수 있습니다(n은 구성 요소의 개수를 나타냅니다).

 - vecn: n개의 부동소수점(float) 값로 이루어진 기본 벡터.
 - bvecn: n개의 불리언 값으로 이루어진 벡터.
 - ivecn: n개의 정수 값으로 이루어진 벡터.
 - uvecn: n개의 부호없는 정수(unsigned integer) 값으로 이루어진 벡터.
 - dvecn: n개의 더블(double) 값으로 이루어진 벡터.

대부분의 경우 부동소수점 숫자가 우리의 목적에 충분하기 때문에 기본적인 vecn을 사용하게 될 것입니다.

벡터의 구성 요소는 `vec.x`와 같이 접근할 수 있으며, 여기서 `x`는 벡터의 첫 번째 구성 요소입니다. `.x`, `.y`, `.z`, `.w`를 사용하면 각각 첫 번째, 두 번째, 세 번째, 네 번째 구성 요소에 접근할 수 있습니다. GLSL에서는 색상에는 `rgba`를, 텍스처 좌표에는 `stpq`를 사용하여 동일한 구성 요소에 접근할 수도 있습니다.

벡터 데이터 타입은 **스위즐링(swizzling)**{:.g}이라는 흥미롭고 유연한 구성 요소 선택 기능을 제공합니다. 스위즐링을 사용하면 다음과 같은 구문을 사용할 수 있습니다.

```glsl
vec2 someVec;
vec4 differentVec = someVec.xyxx;
vec3 anotherVec = differentVec.zyw;
vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
```

원본 벡터에 해당 구성 요소가 있는 한, 최대 4개의 문자를 조합하여 새 벡터(동일한 타입)를 생성할 수 있습니다. 하지만 예시로 vec2의 .z 구성 요소에는 접근할 수 없습니다. 또한 벡터를 다른 벡터 생성자 호출의 인수로 전달하여 필요한 인수의 수를 줄일 수 있습니다.

```glsl
vec2 vect = vec2(0.5, 0.7);
vec4 result = vec4(vect, 0.0, 0.0);
vec4 otherResult = vec4(result.xyz, 1.0);
```

벡터는 모든 종류의 입력과 출력에 사용할 수 있는 유연한 데이터 유형입니다. 이 책 전체에서 벡터를 창의적으로 활용하는 다양한 예제를 보게 될 것입니다.

### 인앤아웃

> 햄버거가 아니라 인풋(input)과 아웃풋(output)입니다!

셰이더는 그 자체로 훌륭한 프로그램이지만, 전체 시스템의 일부이기 때문에 각 셰이더에 입력과 출력을 지정하여 변수를 이동시킬 수 있도록 해야 합니다. GLSL은 이러한 목적을 위해 `in`과 `out` 키워드를 정의했습니다. 각 셰이더는 이 키워드를 사용하여 입력과 출력을 지정할 수 있으며, 출력 변수가 다음 셰이더 단계의 입력 변수의 타입과 일치하면 해당 변수가 전달됩니다. 다만, 정점 셰이더와 프래그먼트 셰이더는 약간 다릅니다.

정점 셰이더는 어떤 형태로든 입력을 받아야 제대로 작동합니다. 정점 셰이더는 입력을 정점 데이터에서 직접 받는다는 점에서 다른 셰이더와 차별화됩니다. 정점 데이터의 구조를 정의하기 위해 입력 변수에 위치 메타데이터를 지정하여 CPU에서 정점 속성을 설정할 수 있도록 합니다. 이전 장에서 `layout (location = 0)`으로 이를 살펴보았습니다. 따라서 정점 셰이더는 입력에 대한 추가적인 레이아웃 지정이 필요하며, 이를 통해 정점 데이터와 연결할 수 있습니다.

!!! tip ""
    `layout (location = 0)`를 생략하고 OpenGL 코드에서 `glGetAttribLocation`을 통해 속성 위치를 조회하는 것도 가능하지만, 저는 정점 셰이더에서 설정하는 것을 선호합니다. 이해하기 쉽고 (여러분과 OpenGL 모두) 작업량을 줄여줍니다.

또 다른 예외 사항은 프래그먼트 셰이더가 최종 출력 색상을 생성해야 하므로 vec4 색상 출력 변수가 필요하다는 것입니다. 프래그먼트 셰이더에서 출력 색상을 지정하지 않으면 해당 프래그먼트의 색상 버퍼 출력이 정의되지 않은 상태가 됩니다(일반적으로 그런 상황에서 OpenGL은 해당 프래그먼트를 검정색 또는 흰색으로 렌더링합니다).

따라서 한 셰이더에서 다른 셰이더로 데이터를 보내려면 보내는 셰이더에 출력 변수를 선언하고 받는 셰이더에도 동일한 입력 변수를 선언해야 합니다. 양쪽에서 변수의 타입과 이름이 같으면 OpenGL은 해당 변수들을 연결하고, 그 후 셰이더 간에 데이터를 주고받을 수 있게 됩니다(프로그램 객체를 연결할 때 이 과정이 수행됩니다). 실제로 어떻게 작동하는지 보여주기 위해 이전 장에서 다룬 셰이더들을 수정하여 정점 셰이더가 프래그먼트 셰이더의 색상을 결정하도록 하겠습니다.

**정점 셰이더**

```glsl
#version 330 core
layout (location = 0) in vec3 aPos; // the position variable has attribute position 0
  
out vec4 vertexColor; // specify a color output to the fragment shader

void main()
{
    gl_Position = vec4(aPos, 1.0); // see how we directly give a vec3 to vec4's constructor
    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // set the output variable to a dark-red color
}
```

**프래그먼트 셰이더**

```glsl

#version 330 core
out vec4 FragColor;
  
in vec4 vertexColor; // the input variable from the vertex shader (same name and same type)  

void main()
{
    FragColor = vertexColor;
}
```

보시다시피, 정점 셰이더에서 설정하는 vec4 출력 변수인 `vertexColor`를 선언했고, 프래그먼트 셰이더에서도 유사하게 `vertexColor` 입력 변수를 선언했습니다. 두 변수의 타입과 이름이 같기 때문에 프래그먼트 셰이더의 `vertexColor`는 정점 셰이더의 `vertexColor`와 연결됩니다. 정점 셰이더에서 색상을 진한 빨간색으로 설정했으므로, 결과 프래그먼트도 진한 빨간색이 되어야 합니다. 다음 이미지는 그 결과를 보여줍니다.

![](../static/shaders.png)

자, 이제 됐어요! 정점 셰이더에서 프래그먼트 셰이더로 값을 전달하는 데 성공했습니다. 이제 좀 더 특별하게 애플리케이션에서 프래그먼트 셰이더로 색상을 전달할 수 있는지 확인해 볼까요!

### 유니폼

**유니폼(Uniforms)**{:.g}은 CPU에서 실행되는 애플리케이션의 데이터를 GPU의 셰이더로 전달하는 또 다른 방법입니다. 하지만 유니폼은 정점 속성과는 약간의 차이가 있습니다. 첫째, 유니폼은 전역 변수입니다. 전역 변수란 셰이더 프로그램 객체별로 고유한 값을 가지며, 프로그램의 어느 단계에서든 모든 셰이더에서 접근할 수 있음을 의미합니다. 둘째, 유니폼 값을 어떤 값으로 설정하든, 해당 값은 재설정되거나 업데이트될 때까지 유지됩니다.